# Asfaload file signature specification

This document describes the signature scheme proposed by Asfaload to authenticate files published on the internet.
The authentication ensures the files published were made available by the people controlling the publishing account.

# File publishing workflow

To integrate with the Asfaload signature scheme, the published file needs to be covered by a checksums file generated by `sha256sum` or `sha512sum`.
This checksums file needs to be published alongside the file proposed for download.

This checksums file is mirrored in a git repository maintained by Asfaload. The path on the mirror is the download uri of the file, without the protocol scheme.
For example, the file available at URI `https://github.com/asfaload/asfald/releases/download/v0.5.1/checksums.txt` will be found in the mirror at the following
path: `github.com/asfaload/asfald/releases/download/v0.5.1/checksums.txt`.
A file can be present in multiple checksums files, e.g. one generated by `sha256sum` and one generated by `sha512sum`.
All checksums files are parsed and their content is put in the file `asfaload.index.json`. This index file makes it easy to identify the value of the checksum
for a file, as well as its location on the publishing platform.

It is the file `asfaload.index.json` that will be signed by publishers.

# Publishing Repo

## Initial signers

### Github
Added in root of git repo as `asfaload.signers.json` with the format
```
{
  "version": 1,
  "threshold": {
   "signatures_required": 1,
  },
  "signers" : [
    { "format": "minisign", "pubkey": "RWTsbRMhBdOyL8hSYo/Z4nRD6O5OvrydjXWyvd8W7QOTftBOKSSn3PH3"  },
    { "format": "minisign", "pubkey": "RWTUManqs3axpHvnTGZVvmaIOOz0jaV+SAKax8uxsWHFkcnACqzL1xyv"  },
    { "format": "minisign", "pubkey": "RWSNbF6ZeLYJLBOKm8a2QbbSb3U+K4ag1YJENgvRXfKEC6RqICqYF+NE"  }
  ]
}
```
When asfaload copies this file to the mirror, it is not signed yet and has the suffix `.pending` added. Signatures will be collected on the mirror.
Each user controlling a secret key corresponding to a public key listed will have to sign the `asfaload.signers.json` file and provide the signature to the
Asfaload backend.

The backend will place the signature files on the mirror under `${project_root}/asfaload/signatures.pending/${base64_of_pub_key}`.
Here `${project_root}` is the path `/github.com/${user}/${repo}` on the mirror.
Each signer provides its signature, and it is immediately committed to the mirror.
When all required signatures are collected, the file and directory are renamed by the backend to remove the `.pending` suffix, effectively becoming the
active signature configuration.

# Mirror

## Signers modifications

A new version of the file `asfaload.signers.json` is sent to our backend, signed by one of the current signers.
The new file is copied with the suffix `.pending` added and a directory `signatures.pending` is created to the repo's
root directory on the mirror.

To transition to the new setup, 3 conditions have to be met:
* The current signatories need to sign the new signers file according to the current signers file.
* The new signers file needs to be respected too.
* Any new signer is required to sign.

Example:
old: { threshold 2, signers [ A, B, C ]}
new: { threshold 3, signers [ A, B, C, D]}

This leads to these condition having to be met before transitioning to the new signature config:
* We need 2 signatures from A B C
* We need 3 signatures from A B C D
* We need signature D as it is a new signer.

An acceptable set of signatures of A B D, as it fulfills all 3 conditions.

Lowering the threshold example:
old: { threshold 3, signers [ A, B, C, D]}
new: { threshold 2, signers [ A, B, C, D]}

This leads to these conditions having to be met:
* 3 signatures from A B C D
* 2 signatures from A B C D, which is covered by the first condition
* no new signer is added, so no additional signature is required

> [!NOTE]
> The initial signers file process is a special case of these conditions, where there is no
> current config, and where all signers are new, which lets us condense everything in one requirement (all signers need to sign).

While collecting signatures, the new signatures are added under `signatures.pending` and committed to the mirror.
As soon as the 3 conditions are met, the file and directory are renamed, dropping the `.pending` suffix, and replacing the previous signers files
(which can still be found by looking at the git history if needed).


## New release

The checksums files are mirrored and the `asfaload.index.json` file is created. The current `asfaload.signers.json` file is also copied
under the release directory on the mirror.
Signatures are requested according to the signers file just copied to the release directory on the mirror.
For our example, let's assume that the key `RWTsbRMhBdOyL8hSYo/Z4nRD6O5OvrydjXWyvd8W7QOTftBOKSSn3PH3` is signing the release.
That user signs the `asfaload.index.json` file, and puts its signature under the release directory on the mirror in the subdirectory `signature.pending`
in a file named to the base64 encoding of the public key used: `signatures/UldUc2JSTWhCZE95TDhoU1lvL1o0blJENk81T3ZyeWRqWFd5dmQ4VzdRT1RmdEJPS1NTbjNQSDMK`.
When required signatures are collected, the directory `signature.pending` is renamed to `signatures`.


## Revocation

If a file published and signed appears to be malicious, the publishing project can revoke the signatures.
The revocation has to be signed according to the same conditions as a new release, i.e. respecting the file `asfaload.signers.json` of the project
(not the copy that was taken in the release directory at the time of the release. A revocation has to be done by current signers).

The revocation can be initiated by one of the signers. Revocation is done by setting the top field `revoked` in the file `asfaload.index.json` to `true`.
The file is updated and saved as `asfaload.index.json.pending` under the release directory and signatures are collected in the directory `signatures.pending`.
Once required signatures have been collected, the current `asfaload.index.json` and `signatures` are deleted and pending file and directory are renamed to
drop the `.pending` suffix, making it the current version.

> [!NOTE]
> The process is the same as signing a new release.

The revocation process always looks at the current signers. This means that if the file `asfaload.signers.json` is updated while a revocation is pending,
the signature requirements will change during the revocation process.

# Downloading a file

1. The downloader tool downloads the `asfaload.signers.json` file from the file's directory on the mirror, so it identifies the current signers on the mirror in the release directory.
2. The downloader initialises its valid signature count to 0.
3. The downloader downloads the file `asfaload.index.json`.
4. It extracts the threshold from the file and iterates over the authorised signers.
5. For each signer, it extracts the public key, and computes its base64 encoding (let's call it key64).
6. It looks under the file's directory on the mirror if it finds the signature file for that public key.
To do that it looks for a file with the name `$key64` under the directory `signatures`.
7. If the signature file is found, it downloads it.
8. As the downloader tool knows the public key, the signature, and the `asfaload.index.json` file, it can validate the signature. If the signature is valid, it increases its valid signatures count by 1.
9. If the signature count is equal to the threshold, the signature is complete and we stop iterating over signers in `asfaload.signers.json`
10. The file to be downloaded is now effectively downloaded
11. Once downloaded, the file's checksum is computed. The algorithm chosen by default is the best one found for the file (sha512 > sha256)
12. The checksum computed is compared to the checksums found in the `asfaload.index.json` and with the checksums file on the publishing platform. If all correspond, the file is saved at the requested location.
