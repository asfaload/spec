# Asfaload file signature specification

This document describes the signature scheme proposed by Asfaload to authenticate files published on the internet.
The authentication ensures the files published were made available by the people controlling the publishing account.

# File publishing workflow

To integrate with the Asfaload signature scheme, the published file needs to be covered by a checksums file generated by `sha256sum` or `sha512sum`.
This checksums file needs to be published alongside the file proposed for download.

This checksums file is mirrored in a git repository maintained by Asfaload. The path on the mirror is the download uri of the file, without the protocol scheme.
For example, the file available at URI `https://github.com/asfaload/asfald/releases/download/v0.5.1/checksums.txt` will be found in the mirror at the following
path: `github.com/asfaload/asfald/releases/download/v0.5.1/checksums.txt`.
A file can be present in multiple checksums files, e.g. one generated by `sha256sum` and one generated by `sha512sum`.
All checksums files are parsed and their content is put in the file `asfaload.index.json`. This index file makes it easy to identify the value of the checksum
for a file, as well as its location on the publishing platform.

It is the file `asfaload.index.json` that will be signed by publishers.

# Publishing Repo

## Initial signers

### Github
Before a project starts to sign releases with Asfaload, it has to communicate the signers and threshold to the Asfaload mirror.
This is done by adding a file `asfaload.signers.json` of the git repo under the branch name `join_asfaload`. Once the file has been copied
to the mirror, the branch can be deleted and all further processing will happen on the mirror.
> [!NOTE]
> Using a dedicated branch that can be deleted avoids to clutter the work
> branch of the repo, and have signers in the repo out of sync with the mirror
> when signers are updated.
> The downside is that once the branch is deleted, there's no trace left. We
> don't expect this to be problematic, looking at how Let's Encrypt has been
> successful with the same approach.

```
{
  "version": 1,
  "threshold": {
   "signatures_required": 1,
  },
  "signers" : [
    { "format": "minisign", "pubkey": "RWTsbRMhBdOyL8hSYo/Z4nRD6O5OvrydjXWyvd8W7QOTftBOKSSn3PH3"  },
    { "format": "minisign", "pubkey": "RWTUManqs3axpHvnTGZVvmaIOOz0jaV+SAKax8uxsWHFkcnACqzL1xyv"  },
    { "format": "minisign", "pubkey": "RWSNbF6ZeLYJLBOKm8a2QbbSb3U+K4ag1YJENgvRXfKEC6RqICqYF+NE"  }
  ]
}
```
When asfaload copies this file to the mirror, it is not signed yet and has the suffix `.pending` added. Signatures will be collected on the mirror.
Each user controlling a secret key corresponding to a public key listed will have to sign the `asfaload.signers.json` file and provide the signature to the
Asfaload backend.

The backend will place the signature files on the mirror under `${project_root}/asfaload/signatures.pending/${base64_of_pub_key}`.
Here `${project_root}` is the path `/github.com/${user}/${repo}` on the mirror.
Each signer provides its signature, and it is immediately committed to the mirror.
When all required signatures are collected, the file and directory are renamed by the backend to remove the `.pending` suffix, effectively becoming the
active signature configuration.

# Mirror

## Signers modifications

A new version of the file `asfaload.signers.json` is sent to our backend, signed by one of the current signers.
The new file is copied with the suffix `.pending` added and a directory `signatures.pending` is created to the repo's
root directory on the mirror.

To transition to the new setup, 3 conditions have to be met:
* The current signatories need to sign the new signers file according to the current signers file.
* The new signers file needs to be respected too.
* Any new signer is required to sign.

Example:
old: { threshold 2, signers [ A, B, C ]}
new: { threshold 3, signers [ A, B, C, D]}

This leads to these condition having to be met before transitioning to the new signature config:
* We need 2 signatures from A B C
* We need 3 signatures from A B C D
* We need signature D as it is a new signer.

An acceptable set of signatures of A B D, as it fulfills all 3 conditions.

Lowering the threshold example:
old: { threshold 3, signers [ A, B, C, D]}
new: { threshold 2, signers [ A, B, C, D]}

This leads to these conditions having to be met:
* 3 signatures from A B C D
* 2 signatures from A B C D, which is covered by the first condition
* no new signer is added, so no additional signature is required

> [!NOTE]
> The initial signers file process is a special case of these conditions, where there is no
> current config, and where all signers are new, which lets us condense everything in one requirement (all signers need to sign).

While collecting signatures, the new signatures are added under `signatures.pending` and committed to the mirror.
As soon as the 3 conditions are met, the file and directory are renamed, dropping the `.pending` suffix, and replacing the previous signers files
(which can still be found by looking at the git history if needed).


## New release

The checksums files are mirrored and the `asfaload.index.json` file is created. The current `asfaload.signers.json` file is also copied
under the release directory on the mirror.
Signatures are requested according to the signers file just copied to the release directory on the mirror.
For our example, let's assume that the key `RWTsbRMhBdOyL8hSYo/Z4nRD6O5OvrydjXWyvd8W7QOTftBOKSSn3PH3` is signing the release.
That user signs the `asfaload.index.json` file, and puts its signature under the release directory on the mirror in the subdirectory `signature.pending`
in a file named to the base64 encoding of the public key used: `signatures/UldUc2JSTWhCZE95TDhoU1lvL1o0blJENk81T3ZyeWRqWFd5dmQ4VzdRT1RmdEJPS1NTbjNQSDMK`.
When required signatures are collected, the directory `signature.pending` is renamed to `signatures`.


## Revocation

If a file published and signed appears to be malicious, the publishing project can revoke the signatures.
The revocation has to be signed according to the same conditions as a new release, i.e. respecting the file `asfaload.signers.json` of the project
(not the copy that was taken in the release directory at the time of the release. A revocation has to be done by current signers).

The revocation can be initiated by one of the signers. Revocation is done by setting the top field `revoked` in the file `asfaload.index.json` to `true`.
The file is updated and saved as `asfaload.index.json.pending` under the release directory and signatures are collected in the directory `signatures.pending`.
Once required signatures have been collected, the current `asfaload.index.json` and `signatures` are deleted and pending file and directory are renamed to
drop the `.pending` suffix, making it the current version.

> [!NOTE]
> The process is the same as signing a new release.

The revocation process always looks at the current signers. This means that if the file `asfaload.signers.json` is updated while a revocation is pending,
the signature requirements will change during the revocation process.

## Multi-sig analysis
### Key compromise

A key compromise is the event making the private key of a signer available to a third-party not supposed to have it.
If not handled correctly, such an event can be catastrophic and lead to publication and seemingly valid signing of malicious software.
Handling it correctly however is hard and may require some constraints.
Multi-signatures accounts can limit the impact of a key compromise, but only under certain circumstances. For example, a 1-of-2 account does not
bring any protection against key compromise, as the compromised key can take any action, including updating the signers.
As a conclusion, we can say that to protect against key-compromise, the multi-sig needs to require more than one signature (in n-of-m, n>1).
Also, per definition, an n-of-m multi-sig with m>n can protect against n-1 key compromise. (Compromised keys alone cannot validly sign, and
the participation of at least one non-compromised key is needed).
Of note is that the compromised key can still be used by its owner to sign multi-sig operations as long as it has not been revoked.
This means that the compromised key can sill participate in the n-of-m multi-sig to validate signers updates.

> [!NOTE]
> An n-of-m account can protect against the compromise n-1 keys.
### Key loss

A key loss event is quiet similar to a key compromise, with the difference that the key cannot sign anything.
If in the case of a key-compromise, said key can still participate to sign updates to the signers list, this is not the
case with a key loss.
It means that remaining signers should be able to sign changes.
As a conclusion, to protect against a key loss, we need to have n<m.
For a 3-of-5 account, we require the signature of 3 keys out of 5, meaning it can handle 2 key losses.
We can generalise this and say that an account n-of-m protects against m-n key losses.
> [!NOTE]
> An n-of-m account can protect against m-n key losses.

### Key compromises and key losses

For an n-of-m account, the worst situation is to have n-1 key compromised, and m-n other keys lost.
In that case, updates to the signers list can be signed by the n-1 owners of the compromised keys.
With m-n keys lost, it still means that n keys are available. n-1 of these are compromised, but it means that
on key is still safe and will be able to limit updates to the signers list to legitimate updates.

At the other end of the spectrum, if all lost keys are amongst the compromised keys, we are still safe.
We have n-1 keys compromised, and m-n keys lost.
If m-n>n-1, it means we have lost access to all compromised keys in addition
to some non-compromised keys. All accessible keys remaining are not compromised and can be safely used to
update the signers list.
We can illustrate this with a 3-of-8. Let's say we have the keys labeled `A` `B` `C` `D` `E` `F` `G` `H`.
We have 3-1 = 2 compromised keys (let's say A B, which we mark with *), and 8-3 = 5 keys lost (which we mark with x), of which 2 are compromised:
`Ax*` `Bx*` `C*` `D*` `E*` `F` `G` `H`

If m-n < n-1, it means we have lost less keys than the number of compromised keys.
For example, in a 3-of-4, we have 3-1 = 2 (compromises handled), and 4-3=1 (key loss handled).
Let's say we have the 4 keys labels `A`, `B`, `C`, and `D` and `A` and `B` are compromised (we mark them with a `*`). As
stated earlier, in this case all keys lost are amongst the compromised keys. So let's say `A` is lost (we mark it with `x`)
We end up with these keys: `Ax*` `B*` `C` `D`. We see we have keys `B*` `C` `D` available to generate a valid signature, and we need to
use a compromised key to sign the signers update.
We can generalise and say that when m-n < n-1 we will need to use compromised keys to update the signers list. But as the update still requires the signature of a non-compromised key,
the update is safe.

Multi-sig accounts protect against any combination between these two extremes.



# Downloading a file

1. The downloader tool downloads the `asfaload.signers.json` file from the file's directory on the mirror, so it identifies the current signers on the mirror in the release directory.
2. The downloader initialises its valid signature count to 0.
3. The downloader downloads the file `asfaload.index.json`.
4. It extracts the threshold from the file and iterates over the authorised signers.
5. For each signer, it extracts the public key, and computes its base64 encoding (let's call it key64).
6. It looks under the file's directory on the mirror if it finds the signature file for that public key.
To do that it looks for a file with the name `$key64` under the directory `signatures`.
7. If the signature file is found, it downloads it.
8. As the downloader tool knows the public key, the signature, and the `asfaload.index.json` file, it can validate the signature. If the signature is valid, it increases its valid signatures count by 1.
9. If the signature count is equal to the threshold, the signature is complete and we stop iterating over signers in `asfaload.signers.json`
10. The file to be downloaded is now effectively downloaded
11. Once downloaded, the file's checksum is computed. The algorithm chosen by default is the best one found for the file (sha512 > sha256)
12. The checksum computed is compared to the checksums found in the `asfaload.index.json` and with the checksums file on the publishing platform. If all correspond, the file is saved at the requested location.
